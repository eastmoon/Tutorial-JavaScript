JavaScript Framework - AngularJS
https://angularjs.org/

Ref：Learn Angular, http://www.learn-angular.org/#!/lessons/the-essentials
Ref：AngularJS Document, https://docs.angularjs.org/api/ng
Ref：AngularJS Tutorial for Demo, http://www.tutorialspoint.com/angularjs/index.htm
Ref：AngularJS 開發實戰：重要的開發觀念與經驗分享, http://www.slideshare.net/WillHuangTW/angular-js-coscup2013?related=1
Ref：AngularJS 開發實戰：解析 angular-seed 專案架構與內容, http://www.slideshare.net/WillHuangTW/angularjs-angularseed

AngularJS使用MVC架構，其中核心三大元件為
(1. Template ( View )
樣板系統，利用此系統，將靜態文檔(Static DOM)的HTML與動態文檔(Dynamic DOM)的Template整合為可受架構控制的頁面。
(2. Scope ( Model )
Angular核心，用於管理、呈現資料、反應介面事件，透過Scope整合Template與Controller的溝通。
(3. Controller
事件系統，經過Scope登記Controller，並建構整個應用程式 ( Application，單一<HTML></HTML>夾住的頁面 )的運作邏輯。

◎ HTML Compiler
https://docs.angularjs.org/guide/compiler

◎ Bootstrap
https://docs.angularjs.org/guide/bootstrap
Demo：AngularJS-2-1_Basics-Bootstrap.html

當網頁載入完成後Angular會依據開發者於<HTML>標籤所設定的Module進行DI(Dependency Injection)，並對整份文件進行Compile。
因此，Angular的自動化會有以下步驟：

1. DOMContentLoaded事件發生；Document文件載入完畢
2. Directive關聯Module載入
3. 建立應用程式的相依注入 (Dependency Injection)
4. 編譯文件，將所有指令關聯建利

在這程序中會出現一種狀況，前置資訊處理。
亦即，文件編譯前需與後端擷取資料、延遲載入檔案(JS、CSS)等狀況。

例如：Demo程式，透過標準程序載入JavaScript起始設定檔，在依據設定需要載入動態檔案，包含所需的JS檔。
在這程序中，會因為違背自動化程序而無法順利編譯。

例如：Ref文件，編譯前需依外部資訊動態選擇Module，則會因為自動化過程無法動態修改。

這些問題可以單純由後端頁面產生時，由後端動態產生檔案時處理；但這將使得Frontend與Backend間關係相依，亦會導致Frontend無法獨立製作。
但這並非絕對需要的設計法則，依據不同系統需求，過度分隔系統也為導製系統程序複雜化。

◎ Angular Expressions
https://docs.angularjs.org/guide/expression
Demo：AngularJS-1_Expressions.html

Angular運算式(表示式)特徵：
- Contextl：JavaScript運算式在全域運算著，Angular運算式在Scope內運算。
- Forgiving：型態檢查寬鬆，在JavaScript當計算內容有undefined屬性會傳出錯誤，在Angular執行則允許undefined與null列入運算。
- No Control Flow Statements：不可於運算式內執行條件式、迴圈、例外式。
- No Function Declarations：不可宣告函數，即使是在初始化指令(Directive)。
- No RegExp Creation With Literal Notation：不可執行正規表達式。
- No Comma And Void Operators：不可使用或指定Void(無形態)。
- Filters：在其顯示前，可對運算式的資料格式使用過濾器。

◎ Angular Services API
- Services
https://docs.angularjs.org/guide/services
http://www.learn-angular.org/#!/lessons/handling-complexity
Demo：AngularJS-1_Services.html
Demo：AngularJS-1_MultiModule.html

- Providers
https://docs.angularjs.org/guide/providers
https://docs.angularjs.org/api/auto/service/$provide
Demo：AngularJS-1_Provider.html

》》Angular服務介面具有兩種特性：

1. 延遲實例化，Lazily instnatiated
應用程式實例化，在於原件只應相依時。
Lazily instantiated – Angular only instantiates a service when an application component depends on it.

2. 唯一化，Singletons
每個原件相依於服務，且服務工廠會以參照對應於實體；單一參照不會對應多個實體。
Singletons – Each component dependent on a service gets a reference to the single instance generated by the service factory.

『When Angular creates services, it creates them as singleton objects which are stored in a cache. When a service is injected into a method, the cached object is what is actually passed as an argument. This means that if your service returns a reference type, all methods which take the service as an argument will actually receive a reference to the same object. You must therefore be careful if you choose to modify the object, as the changes you make will be application-wide.*』

當Angular建立服務時，會產生一個唯一物件並儲存於暫存中。
在服務備注入於方法函數時，暫存物建將是實際傳遞的參數。
這表示，若服務回傳的是參照型態，則所有方法函數將會取得同一暫存實體得參照位置。
請務必小心修改物件內容，確保在改動在應有的應用範圍內。

While the code above is well on its way to becoming a modular, extensible Angular app, we can actually take all this one step further. The AngularJS team recommends that applications be split into several modules, defined according to the following logic.

Create one module for each feature
Create one module for each reusable component
Create an application level module which depends on the above modules and contains any initialization code.

AngularJS團隊建議，為有利於擴展Angular應用程式，應將應用程式切分成數個不同的模組。

1. 建立一個特徵模組
2. 建立一個重用元件模組
3. 建立一個應用程式模組，使其相依於上述模組，並包含其初始化設定等程式。

To make our application a bit more flexible, we can split it into two modules: one which will contain the value service, and one which will contain the controller.
同上所述，為使應用程式更為靈活，應將模組切分為二，一個含括數值、物件服務介面，一個含括應用控制邏輯。

》》Angular服務介面在相依定義後，可區分為兩種物件型態，服務與專門物件：

1. 服務：
服務為開發者自行定義的服務邏輯與資訊。
Services are objects whose API is defined by the developer writing the service.

2. 專門物件：
用於符合Angular框架的應用介面，如控制器(Controllers)、指令(Directives)、過濾器(Filters)、動畫(Animations)。
Specialized objects conform to a specific Angular framework API. These objects are one of controllers, directives, filters or animations.

Providers，提供者；在此意指用於服務設定的物件，此物件主要提供開發者登記對應的"處方"(recipe)於服務，並透過服務產生實例於應用程式。
而依據上述內容，模組提供的應用介面列表可區分如下：

Module API List：
Ref：Module API, https://docs.angularjs.org/api/ng/type/angular.Module

○ Services：
└ Provider
└ Factory
└ Service
└ Value
└ Constant

● Framework event：
└Config
└Run

○ Specialized objects：
└Decorator
└Animation
└Filter
└Controller
└Directive
└Component

Services 主要說明：

Value(obj) - registers a value/object that can only be accessed by services, not providers.
登記一個可供服務存取的數值或物件，但供應者(Providers)不可存取。

Constant(obj) - registers a value/object that can be accessed by providers and services.
登記一個可供服務、供應者存取的數值或物件。
Value與Constant最大差別在於供應者建立時的設定階段(Configuration phase)，Value不可於此時使用，但Constant可以。

Factory(fn) - registers a service factory function, fn, that will be wrapped in a service provider object, whose $get property will contain the given factory function.
登記一個服務工廠函數，並封裝於一個服務提供物件內，且$get屬性將包含此工廠函數；這部分程序為自動處理。
在設計上，Factory可以產生一個或依據參數演算應輸出的實例物件，並不需與Value或Constant相同唯一個固定的數值或物件。

Service(class) - registers a constructor function, class that will be wrapped in a service provider object, whose $get property will instantiate a new object using the given constructor function.
登記一個建構函數，此物件將會被封裝於一個服務提供物件內，且$get屬性將使用此建構函數實體化物件；這部分程序為自動處理。
設計上，Service與Factory相似，但原則上Service可以是Factory的建構。
且從設計目的Constructor Injection考量，使用Service應考慮對物件的邏輯與數值建立過程分開考慮。
Factory重視建構物件，其內容邏輯、方法，以至於邏輯相關的細部設定。
Service重視建構物件，其初始資料、狀態、對應內容等；且利用不同Service對應相同Factory，來做到分割初始資料來源的設計目的。

Provider(provider) - registers a service provider with the $injector
登記一個服務提供者於注入物件。

服務提供者等於上述四種服務的總合 ( Value、Constant、Factory、Service )，其內部可以直接擁有這些服務。
嚴格來說，Provider可視為完整的物件，且實例化後將觸發Configuration與Run兩個框架事件。
但除了觸發框架事件外，其詳細的規劃與設定亦可用於Factory與Service，但使用Provider較能完整處理。

依據實驗結果，可將Provider程式內部可分為數個段落
- Private：
僅用於Provider物件內部操作運用。
不在return返還物件內的一切變數與函數。

- Public for Config：
僅用於Configuration blocks，可視為建構函數。
在return返還物件內，非$get實例化函數的返還物件內。

- Public for Instantiates：
用於Run等實例化注入的方法內，提供給外部物件操作的公開介面。
在return內的$get實例化函數所返還的物件。

- 程式架構如下：
angular.provider( "name", function() {
	// Private
	...
	// Public
	Return {
		// for Config
		xxx : function() {},
		// for Instantiates
		$get : function () { return {...}; }
	};
};

Framework event 主要說明：

Configuration - get executed during the provider registrations and configuration phase. Only providers and constants can be injected into configuration blocks. This is to prevent accidental instantiation of services before they have been fully configured.

執行於服務提供者登記時的設定階段，在這階段只可注入Providers與Constants使用，且服務接尚未實例化。

Run - get executed after the injector is created and are used to kickstart the application. Only instances and constants can be injected into run blocks.

Run blocks are the closest thing in Angular to the main method. A run block is the code which needs to run to kickstart the application. It is executed after all of the services have been configured and the injector has been created.

執行於Configuration後，且注入實例皆已建立，並用此去啟始應用程式，在這階段只可注入實例物件與Constants。
注意，因模組本身即是服務提供者，原則上Run區塊等同於模組的起始方式 ( main method )，在執行此時，諸多服務皆已經完成實例與相對應連接。

◎ Module
https://docs.angularjs.org/guide/module#module-loading-dependencies

◎ Scopes
https://docs.angularjs.org/guide/scope
Demo：AngularJS-1_Scopes.html

『Scope is the glue between application controller and the view. During the template linking phase the directives set up $watch expressions on the scope. The $watch allows the directives to be notified of property changes, which allows the directive to render the updated value to the DOM.』

『The normal flow of a browser receiving an event is that it executes a corresponding JavaScript callback. Once the callback completes the browser re-renders the DOM and returns to waiting for more events.』

Scope運作於應用程式Controller與View之間，在樣板連結過程，指令(Directives)會對Scope設定$watch運算式，而$watch會對指令遞送屬性變更，使指令可以繪製更新資訊於對應的DOM ( HTML element )；在一般流程中，瀏覽器接收到事件，會執行相應的JavaScript函數，當函數完成動作，瀏覽器會重繪DOM元件並繼續等待其他事件。

Controller與Scopes為互相作用的關係：
(1. Controller使用Scopes來設定方式(行為)到Templates
(2. Controller定義的方式(行為)可調整模型(Scopes的屬性)
(3. Controller可註冊監視方式在模型上，這些監視方式運行於控制器方式之後。

當DIV元件設定對應Controller時，兩者間便建立一個Scope實體來傳遞訊息，不論是對應於Angular運算式的變數、對應指令(Directive)的行為、列舉資料，皆是透過Scope來對應。

◎ Custom Directives
https://docs.angularjs.org/guide/directive
Demo：AngularJS-1_Directives.html
Ref：Directives document, https://docs.angularjs.org/api/ng#directive

『At a high level, directives are markers on a DOM element (such as an attribute, element name, comment or CSS class) that tell AngularJS's HTML compiler ($compile) to attach a specified behavior to that DOM element (e.g. via event listeners), or even to transform the DOM element and its children.

Angular comes with a set of these directives built-in, like ngBind, ngModel, and ngClass. Much like you create controllers and services, you can create your own directives for Angular to use. When Angular bootstraps your application, the HTML compiler traverses the DOM matching directives against the DOM elements.』

指令(Directive)是標記在DOM元件上(如屬性、元件名、註記、樣式物件)，這些標記會告訴AngularJS HTML編譯器($compile)去附加特殊行為到DOM元件上(例如增加聆聽事件)，或其DOM元件下的子元件；Angular已完成諸如ngBind、ngModel、ngClass等指令，但就如同你可以建立Controller或Services一樣，亦可建立指令；當Angular啟動應用程式，HTML編譯器便會將對應的DOM元件匹配起來。

指令(Directive)可以看成是Angular為HTML標籤擴增的功能，或用於連結JavaScript動態程式的標籤；其優點是獨有的功能性和與模組(moduler)、控制器(controller)等溝通的便利性，但其缺點亦在於此，觀念上，只要使用Angular的標籤，其右子的內容即為JavaScript語言，但要注意的是，對應標籤需使用的是變數、物件、陣列，送入資訊不同會導致其編譯錯誤。

另外，指令數量繁多，但相對於HTML既存標籤，也並非所有指令皆需理解，這部分需視題目而學習與閱讀。

◎ Angular injector subsystem
Demo：AngularJS-1_Injector.html
Ref：AngularJS 入門教學 - $inject, http://abgne.tw/angularjs/angularjs-getting-stared/inject.html
Ref：Dependency Injection, https://docs.angularjs.org/guide/di

言簡意該的說Dependency Injection：
『設立介面，由不同的物件完成介面的實體，並由需要的當下指派。』

而在Angular的Inject，是指替代傳遞參數的方式；可以指定的參數物件，可以為系統物件($scope, $window etc.)或自定物件(module.factory設定的物件)。

格式：["Object", function( Variable ) {}]
當此設定後Variable實際指向的會是前述的Object。

例如：["$scope", function( a_scope ) {}]
則a_scope實際等於$scope物件。

解釋上，這樣的系統如何對應DI設計，在於透過對應，可將Object各自分開完成設定，在執行時依需求指派對應的物件運行。
且指派物件是以字串設定，表示字串來原可為外部資訊，亦即透過網址或其他來原，使單頁運行於的Object會因外部資訊變動，讓物件間互不依存。

---------------------

Dependency Injection 設計觀念解讀：
http://huan-lin.blogspot.com/2011/10/dependency-injection-1.html

對於繼承(抽象物件)與實做(介面物件)，曾經被問過這樣一個問題。

提問者：『若專案的介面太多，你會怎麼處理？』
在下：『正常情況下，介面不應該過多，若當真過多，則應回到架構層級，整合併刪除多餘介面。』

就個人認知『介面』是『抽象』規範化的結果，這語言結構源自『多重繼承』；但這結構會導致些設計問題，諸如重複且相似的繼承行為，因此現行語言並不支援，也因此改為『單一繼承，多重實做』的架構。

就個人實務經驗，『介面』具有以下特性：
1. 演算抽離物件，使演算與物件保持相依而非耦合。
2. 跨繼承樹，允許導入不同物件群於單一演算。

由於特性1就算不使用介面，在無介面的C++也能以抽象物件保持物件群的獨立性即可。
但是特性2就屬於介面獨有特色，其優點在於無需改動開發者建立的物件群與繼承樹，亦能使其物件導入架構的演算系統內；然而，若需要考慮跨繼承樹的演算用途，就必須依據需求反覆確認其現有介面的適切性，諸如參數、回傳、使用時機等，若要正確設計，一定程度並非從需求面著手，而是從多樣需求的相似性著手，類似策略模式的設計思考。

亦即介面的設計必要性、適當性，是源自架構的多需求抽象化，而非單次題目的需求修改，因為若每次需求來就改動介面，實際上並無法使介面適切的應對所有狀況，更容易發生今非昔比的狀況而修改介面繼承樹。

『以下是幾個可能需要使用或了解 DI 技術的場合：
- 如果你正在設計一套框架（framework）或可重複使用的類別庫，DI 會是很好用的技術。
- 如果你正在開發應用程式，需要在執行時其動態載入、動態切換某些元件，DI 也能派上用場。
- 希望自已的程式碼在將來需求變動時，能夠更容易替換掉其中一部份不穩定的元件（例如第三方元件，此時可能搭配 Adapter 模式使用）。
- 你正在接手維護一個應用程式，想要在重構（refactor）程式碼的時候降低對某些元件的依賴，方便測試以及讓程式碼更好維護。』

如同文中所題，介面並非用於單一特定題目實務設計，而是基於長期系統考量的設計；但並非無需設計，而是設計時沒考慮充分，則會出現沒必要的設計風險。

Reference：
http://huan-lin.blogspot.com/2011/10/dependency-injection-2.html

---------------------

簡易個人解釋『繼承』(抽象物件)與『實做』(介面物件)：

『繼承』者就如同貴族世襲的教育制度，教導個人的品性、行為、體能等。
『實做』者就如同公司對職務提出的操作需求，指定一人於工作上的態度、方式等。

在傳統(C++等中階語言)上『繼承』與『實做』是相同，貴族本身規定的教育制度亦等同於貴族這職業的需求，因此貴族子弟受到的貴族教育來說，只要規範必要的教育方向，這即是『繼承抽象化』；亦如同數學這門學科擁有無數相異研究，但高等教育只需學習運算、代數等基本數學相同。

然而，對於公司的工作來說，單一職務的需求與個人的教育內容並不會完全相同，亦可解釋為產學不契合，因此在進入職場時必會存在磨合期，這即是『介面實做』，而個人不適應工作，即是物件實做介面的難度過大，反之則是繼承以存有介面，前述的貴族職務與教育。

也因為『實做』是指公司的職務的需求，因此只要能通過磨合，任何『繼承』者皆能擔任其職務，這即是『介面可跨繼承樹』。

「我曾在這樣的十字路口：努力學習各種模式，希望成為一個更好的軟體設計師；但現在，為了真正成為更優秀的軟體設計師，我必須降低對模式的依賴。」
—— Joshua Kerievsky. 《Refactoring to Patterns》 作者
	